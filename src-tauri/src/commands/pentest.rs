use anyhow::Result;
use log::{debug, error, info, warn};
use serde::{Deserialize, Serialize};
use std::process::Stdio;
use tauri::{AppHandle, Emitter};
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio::process::Command;

/// 安全测试工具的结果结构
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PentestResult {
    /// 工具名称
    pub tool: String,
    /// 执行状态
    pub status: String,
    /// 执行时间
    pub execution_time: Option<String>,
    /// 原始输出
    pub raw_output: String,
    /// 是否有错误
    pub is_error: bool,
    /// 警告信息
    pub warnings: Vec<String>,
}

/// 检查工具是否已安装
async fn check_tool_installed(tool_name: &str) -> Result<bool, String> {
    let output = Command::new("which")
        .arg(tool_name)
        .output()
        .await
        .map_err(|e| format!("检查工具安装状态失败: {}", e))?;

    Ok(output.status.success())
}

/// 验证目标是否为合法的测试目标
fn validate_target(target: &str) -> Result<(), String> {
    // 基本的目标格式验证
    if target.trim().is_empty() {
        return Err("目标不能为空".to_string());
    }

    // 检查是否为私有IP范围或localhost（允许内网测试）
    let is_safe_target = target.contains("127.0.0.1") 
        || target.contains("localhost")
        || target.starts_with("192.168.")
        || target.starts_with("10.")
        || target.starts_with("172.");

    // 如果不是安全目标，需要额外确认
    if !is_safe_target {
        warn!("尝试扫描外部目标: {}", target);
        // 在实际使用中，这里应该有用户确认机制
    }

    Ok(())
}

/// 执行nmap扫描
#[tauri::command]
pub async fn execute_nmap(
    app: AppHandle,
    target: String,
    options: Option<String>,
) -> Result<PentestResult, String> {
    info!("执行nmap扫描: 目标={}, 选项={:?}", target, options);

    // 验证目标
    validate_target(&target)?;

    // 检查nmap是否已安装
    if !check_tool_installed("nmap").await.unwrap_or(false) {
        return Ok(PentestResult {
            tool: "nmap".to_string(),
            status: "failed".to_string(),
            execution_time: None,
            raw_output: "错误: nmap未安装。请先安装nmap工具。".to_string(),
            is_error: true,
            warnings: vec!["需要安装nmap工具".to_string()],
        });
    }

    let start_time = std::time::Instant::now();

    // 构建nmap命令
    let mut cmd = Command::new("nmap");
    
    // 添加基本安全选项
    cmd.args(["-T4", "--max-rtt-timeout", "1s", "--max-retries", "1"]);
    
    // 添加用户指定的选项
    if let Some(opts) = &options {
        for opt in opts.split_whitespace() {
            cmd.arg(opt);
        }
    }
    
    // 添加目标
    cmd.arg(&target);

    // 设置超时和输出
    cmd.stdout(Stdio::piped())
        .stderr(Stdio::piped());

    info!("执行命令: nmap {:?}", cmd.as_std().get_args().collect::<Vec<_>>());

    // 生成会话ID用于事件隔离
    let session_id = uuid::Uuid::new_v4().to_string();

    // 执行命令
    let mut child = cmd.spawn().map_err(|e| format!("启动nmap失败: {}", e))?;

    let stdout = child.stdout.take().ok_or("获取stdout失败")?;
    let stderr = child.stderr.take().ok_or("获取stderr失败")?;

    let mut output_lines = Vec::new();
    let mut error_lines = Vec::new();

    // 读取输出
    let stdout_reader = BufReader::new(stdout);
    let stderr_reader = BufReader::new(stderr);

    let app_clone = app.clone();
    let session_id_clone = session_id.clone();
    let stdout_task = tokio::spawn(async move {
        let mut lines = stdout_reader.lines();
        let mut collected_lines = Vec::new();
        
        while let Ok(Some(line)) = lines.next_line().await {
            debug!("nmap stdout: {}", line);
            collected_lines.push(line.clone());
            
            // 实时发送输出到前端
            let _ = app_clone.emit(&format!("pentest-output:{}", session_id_clone), &line);
        }
        
        collected_lines
    });

    let app_clone2 = app.clone();
    let session_id_clone2 = session_id.clone();
    let stderr_task = tokio::spawn(async move {
        let mut lines = stderr_reader.lines();
        let mut collected_lines = Vec::new();
        
        while let Ok(Some(line)) = lines.next_line().await {
            error!("nmap stderr: {}", line);
            collected_lines.push(line.clone());
            
            // 实时发送错误到前端
            let _ = app_clone2.emit(&format!("pentest-error:{}", session_id_clone2), &line);
        }
        
        collected_lines
    });

    // 等待进程完成
    let exit_status = child.wait().await.map_err(|e| format!("等待nmap进程失败: {}", e))?;
    
    // 收集所有输出
    output_lines = stdout_task.await.unwrap_or_default();
    error_lines = stderr_task.await.unwrap_or_default();

    let execution_time = start_time.elapsed();
    let execution_time_str = format!("{:.2}s", execution_time.as_secs_f64());

    // 组合输出
    let mut full_output = output_lines.join("\n");
    if !error_lines.is_empty() {
        full_output.push_str("\n--- 错误输出 ---\n");
        full_output.push_str(&error_lines.join("\n"));
    }

    // 生成警告
    let mut warnings = Vec::new();
    if !is_localhost_or_private(&target) {
        warnings.push("扫描外部目标可能违反法律法规，请确保已获得授权".to_string());
    }
    
    if options.as_ref().map_or(false, |o| o.contains("-A") || o.contains("--aggressive")) {
        warnings.push("激进扫描可能触发入侵检测系统".to_string());
    }

    let result = PentestResult {
        tool: "nmap".to_string(),
        status: if exit_status.success() { "completed".to_string() } else { "failed".to_string() },
        execution_time: Some(execution_time_str),
        raw_output: full_output,
        is_error: !exit_status.success(),
        warnings,
    };

    // 发送完成事件
    let _ = app.emit(&format!("pentest-complete:{}", session_id), &result);

    info!("nmap扫描完成: 状态={}, 用时={:?}", result.status, execution_time);

    Ok(result)
}

/// 检查是否为localhost或私有IP
fn is_localhost_or_private(target: &str) -> bool {
    target.contains("127.0.0.1") 
        || target.contains("localhost")
        || target.starts_with("192.168.")
        || target.starts_with("10.")
        || target.starts_with("172.")
}

/// 获取已安装的安全测试工具列表
#[tauri::command]
pub async fn get_available_pentest_tools() -> Result<Vec<String>, String> {
    let tools = vec!["nmap", "dirsearch", "sqlmap", "nikto", "nuclei"];
    let mut available = Vec::new();

    for tool in tools {
        if check_tool_installed(tool).await.unwrap_or(false) {
            available.push(tool.to_string());
        }
    }

    Ok(available)
} 